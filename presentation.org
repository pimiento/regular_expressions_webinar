#+TITLE: Регулярные выражения
#+EMAIL: @pvavilin
#+AUTHOR: @pvavilin
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [smallest]
#+LATEX_HEADER: \usetheme{default}
#+LATEX_HEADER: \usecolortheme{crane}
#+LATEX_HEADER: \RequirePackage{fancyvrb}
#+LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}
#+LaTeX_HEADER: \lstset{basicstyle=\scriptsize\ttfamily}
#+OPTIONS: \n:t ^:nil
* Блобы
* Простая реализация регулярок
  #+NAME: NaiveRE
  #+BEGIN_SRC python :exports none
    def match(regexp: str, text: str) -> bool:
        # Добавим признак конца строки
        text += '\0'
        regexp += '\0'
        if regexp[0] == '^':
            return matchhere(regexp[1:], text)
        for i in range(len(text)):
            if matchhere(regexp, text[i:]):
                return True
        return False


    def matchhere(regexp: str, text: str) -> bool:
        if regexp[0] == '\0':
            return True
        if regexp[1] == '*':
            return matchstar(regexp[0], regexp[2:], text)
        if regexp[0] == '$' and regexp[1] == '\0':
            return text == '\0'
        if text != '\0' and (regexp[0] == '.' or regexp[0] == text[0]):
            return matchhere(regexp[1:], text[1:])
        return False


    def matchstar(c: str, regexp: str, text: str) -> bool:
        i = 0
        # * может быть и для 0 вхождений
        if matchhere(regexp, text[i:]):
            return True
        while text[i] != '\0' and (text == c or c == '.'):
            i += 1
            if matchhere(regexp, text[i:]):
                return True
        return False
  #+END_SRC

  #+BEGIN_SRC python :exports both :results output :tangle naive_re.py :shebang "#!/usr/bin/env python3" :noweb strip-export
    <<NaiveRE>>

    print(match("abc", "abc"))
    print(match("abc$", "xyzabc"))
    print(match("^abc", "xyzabc"))
    print(match("^abc", "abcx"))
    print(match("a*b", "bcd"))
    print(match("a*b", "aaaaabcd"))
  #+END_SRC

  #+RESULTS:
  : True
  : True
  : False
  : True
  : True
  : True
* grep
  #+BEGIN_SRC python :exports none :tangle naive_grep.py :shebang "#!/usr/bin/env python3" :noweb strip-export
    import sys
    import argparse
    <<NaiveRE>>

    parser = argparse.ArgumentParser(prog="grep")
    parser.add_argument(
        "regexp",
        metavar="regexp",
        type=str,
        help="Simplified regexp (^/./*/$)",
    )
    parser.add_argument(
        "fname",
        nargs="*",
        metavar="file",
        type=str,
        help="Path to a file. Read from stdin when there is no file argument"
    )


    def grep(regexp: str, fd: object, name: str = None) -> bool:
        nmatch = 0
        for idx, line in enumerate(fd.readlines()):
            if match(regexp, line.strip()):
                nmatch += 1
                if name is not None:
                    print(f"{name}::{idx+1}: ", end='')
                print(f"{line.strip()}")
        return nmatch


    def main() -> int:
        args = parser.parse_args()
        regexp = args.regexp
        fnames = args.fname
        nmatch = 0
        if len(fnames) == 0:
            if grep(regexp, sys.stdin):
                nmatch += 1
        else:
            for fname in fnames:
                try:
                    with open(fname, "r") as fd:
                        if grep(regexp, fd, fname):
                            nmatch += 1
                except (IOError, OSError) as e:
                    print(e, file=sys.stderr)
                    continue
        return nmatch == 0


    if __name__ == "__main__":
        main()
  #+END_SRC
  #+BEGIN_SRC shell :exports both :results output
    ./naive_grep.py '^def .*(.*):$' ../praktikum_project_5/*/*.py \
        | head -n 5
  #+END_SRC

  #+RESULTS:
  : ../praktikum_project_5/posts/models.py::21: def __str__(self):
  : ../praktikum_project_5/posts/models.py::54: def __str__(self):
  : ../praktikum_project_5/posts/views.py::11: def index(request):
  : ../praktikum_project_5/posts/views.py::33: def group_posts(request, slug):
  : ../praktikum_project_5/posts/views.py::56: def new_post(request):
* Конечные Автоматы
* Язык RE
* Реализация RegExp на конечных автоматах
* Библиотеки для RegExp
* Отладка RegExp
* Практика
